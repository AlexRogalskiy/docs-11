<?xml version="1.0"?>
<fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:db="http://docbook.org/ns/docbook" xmlns:rx="http://www.renderx.com/XSL/Extensions" xmlns:xlink="http://www.w3.org/1999/xlink"><rx:meta-info><rx:meta-field name="author" value="&#10;        James&#10;        Hanna&#10;      "/><rx:meta-field name="creator" value="Kx Systems"/><rx:meta-field name="title" value="Multi-partitioned kdb+ databases &#x2013; an equity options case study"/><rx:meta-field name="keywords" value="Kx, Kx Systems, kdb+, database, equity, kdb+, options, partition,"/></rx:meta-info><rx:outline><rx:bookmark internal-destination="overview-of-the-dataset"><rx:bookmark-label>Overview of the dataset</rx:bookmark-label></rx:bookmark><rx:bookmark internal-destination="options-schema"><rx:bookmark-label>Options schema</rx:bookmark-label></rx:bookmark><rx:bookmark internal-destination="loading-and-saving-data"><rx:bookmark-label>Loading and saving data</rx:bookmark-label></rx:bookmark><rx:bookmark internal-destination="example-queries"><rx:bookmark-label>Example queries</rx:bookmark-label></rx:bookmark><rx:bookmark internal-destination="snapshot-of-option-chain"><rx:bookmark-label>Snapshot of option chain</rx:bookmark-label></rx:bookmark><rx:bookmark internal-destination="building-a-minutely-time-series-of-at-the-money-option-contracts"><rx:bookmark-label>Building a minutely time series of at-the-money option
    contracts</rx:bookmark-label></rx:bookmark><rx:bookmark internal-destination="compression"><rx:bookmark-label>Compression</rx:bookmark-label></rx:bookmark><rx:bookmark internal-destination="conclusion"><rx:bookmark-label>Conclusion</rx:bookmark-label></rx:bookmark></rx:outline><fo:layout-master-set><fo:simple-page-master master-name="cover-page" page-width="210mm" page-height="297mm"><fo:region-body margin-top="0" margin-bottom="0" margin-left="0" margin-right="0" background-color="#eeeded"/></fo:simple-page-master><fo:simple-page-master master-name="toc" page-width="210mm" page-height="297mm" margin-top="30pt" margin-bottom="30pt" margin-left="45pt" margin-right="45pt"><fo:region-body margin-top="48pt" margin-bottom="32pt" margin-left="60pt" margin-right="60pt"/><fo:region-before extent="30pt"/><fo:region-after extent="30pt"/></fo:simple-page-master><fo:simple-page-master master-name="standard-page" page-width="210mm" page-height="297mm" margin-top="30pt" margin-bottom="30pt" margin-left="45pt" margin-right="45pt"><fo:region-body margin-top="48pt" margin-bottom="32pt" margin-left="40pt" margin-right="40pt"/><fo:region-before extent="30pt"/><fo:region-after extent="30pt"/></fo:simple-page-master></fo:layout-master-set><fo:page-sequence master-reference="cover-page" font-family="STIX2" initial-page-number="1" language="en" country="gb"><fo:flow flow-name="xsl-region-body"><fo:block-container absolute-position="absolute" top="0mm" right="0mm" width="2in" height="2in"><fo:block text-align="right"><fo:external-graphic src="url(/Users/sjt/Projects/kx/github/StephenTaylor-Kx/mkdocs2pdf/img/diamond-white.png)" content-width="40mm" scaling="uniform"/></fo:block></fo:block-container><fo:block-container absolute-position="absolute" bottom="0mm" left="0mm" width="2.5in" height="30mm"><fo:block><fo:external-graphic src="url(/Users/sjt/Projects/kx/github/StephenTaylor-Kx/mkdocs2pdf/img/diamond-bottom-left-white.png)" content-width="50mm" scaling="uniform"/></fo:block></fo:block-container><fo:block-container absolute-position="absolute" bottom="0mm" right="0mm" width="4in" height="50mm"><fo:block text-align="right"><fo:external-graphic src="url(/Users/sjt/Projects/kx/github/StephenTaylor-Kx/mkdocs2pdf/img/kx-cover.png)" content-width="75mm"/></fo:block></fo:block-container><fo:block-container absolute-position="absolute" top="35mm" left="15mm"><fo:block color="#0070cd" font-family="Proxima Nova" font-size="60pt" font-weight="bold" letter-spacing="-4pt">kx</fo:block></fo:block-container><fo:block-container absolute-position="absolute" top="40mm" left="40mm"><fo:block><fo:external-graphic src="url(/Users/sjt/Projects/kx/github/StephenTaylor-Kx/mkdocs2pdf/img/its-about-time.png)"/></fo:block></fo:block-container><fo:block-container absolute-position="absolute" top="80mm" left="35mm"><fo:block font-family="Proxima Nova" color="#0070cd" font-size="18pt" font-weight="400">
							Technical Whitepaper
						</fo:block><fo:block margin-top="9pt" margin-right="30mm" line-height="1.4" font-size="24pt" font-weight="400">Multi-partitioned kdb+ databases – an equity options case study</fo:block></fo:block-container><fo:block-container absolute-position="absolute" top="170mm" left="35mm"><fo:block line-height="16pt" font-weight="bold">Date</fo:block></fo:block-container><fo:block-container absolute-position="absolute" top="170mm" left="55mm" width="100mm"><fo:block line-height="16pt" text-align="left"/></fo:block-container><fo:block-container absolute-position="absolute" top="180mm" left="35mm"><fo:block line-height="16pt" font-weight="bold">Author</fo:block></fo:block-container><fo:block-container absolute-position="absolute" top="180mm" left="55mm" width="100mm"><fo:block line-height="16pt" text-align="left"><fo:block line-height="16pt" space-after="9pt" text-align="justify">
        James Hanna, has helped design and develop kdb+ implementations
        and proof of concepts for more than 40 customers. Based in New
        York, James is a Technical Architect for Kx, a high-performance
        data-management, event-processing and trading platform.
      </fo:block></fo:block></fo:block-container><fo:block> </fo:block></fo:flow></fo:page-sequence><fo:page-sequence master-reference="toc" font-family="STIX2" language="en" country="gb"><fo:static-content flow-name="xsl-region-before"><fo:block text-align-last="justify" font-family="Proxima Nova" color="gray"><fo:inline font-size="9pt">Multi-partitioned kdb+ databases – an equity options case study</fo:inline><fo:leader leader-pattern="space"/><fo:inline color="#0070cd" font-size="18pt" font-weight="bold" letter-spacing="-2pt">kx</fo:inline></fo:block></fo:static-content><fo:static-content flow-name="xsl-region-after"><fo:block color="gray" text-align="right"><fo:inline font-family="Proxima Nova" font-size="9pt" letter-spacing="2pt"><fo:page-number/></fo:inline></fo:block></fo:static-content><fo:flow flow-name="xsl-region-body"><fo:block break-before="page"><fo:block font-size="14pt" text-align="center" margin-top="36pt" margin-bottom="36pt">Contents</fo:block><fo:block margin-bottom="6pt" text-align-last="justify"><fo:basic-link internal-destination="idm133660854048">Overview of the dataset <fo:leader leader-pattern="dots"/> <fo:page-number-citation ref-id="idm133660854048"/></fo:basic-link></fo:block><fo:block margin-bottom="6pt" text-align-last="justify"><fo:basic-link internal-destination="idm133660845104">Options schema <fo:leader leader-pattern="dots"/> <fo:page-number-citation ref-id="idm133660845104"/></fo:basic-link></fo:block><fo:block margin-bottom="6pt" text-align-last="justify"><fo:basic-link internal-destination="idm133660838720">Loading and saving data <fo:leader leader-pattern="dots"/> <fo:page-number-citation ref-id="idm133660838720"/></fo:basic-link></fo:block><fo:block margin-bottom="6pt" text-align-last="justify"><fo:basic-link internal-destination="idm133660812640">Example queries <fo:leader leader-pattern="dots"/> <fo:page-number-citation ref-id="idm133660812640"/></fo:basic-link></fo:block><fo:block margin-bottom="6pt" text-align-last="justify"><fo:basic-link internal-destination="idm133660782608">Snapshot of option chain <fo:leader leader-pattern="dots"/> <fo:page-number-citation ref-id="idm133660782608"/></fo:basic-link></fo:block><fo:block margin-bottom="6pt" text-align-last="justify"><fo:basic-link internal-destination="idm133660771584">Building a minutely time series of at-the-money option
    contracts <fo:leader leader-pattern="dots"/> <fo:page-number-citation ref-id="idm133660771584"/></fo:basic-link></fo:block><fo:block margin-bottom="6pt" text-align-last="justify"><fo:basic-link internal-destination="idm133660764912">Compression <fo:leader leader-pattern="dots"/> <fo:page-number-citation ref-id="idm133660764912"/></fo:basic-link></fo:block><fo:block margin-bottom="6pt" text-align-last="justify"><fo:basic-link internal-destination="idm133660761600">Conclusion <fo:leader leader-pattern="dots"/> <fo:page-number-citation ref-id="idm133660761600"/></fo:basic-link></fo:block></fo:block></fo:flow></fo:page-sequence><fo:page-sequence master-reference="standard-page" font-family="STIX2" language="en" country="gb"><fo:static-content flow-name="xsl-region-before"><fo:block text-align-last="justify" font-family="Proxima Nova" color="gray"><fo:inline font-size="9pt">Multi-partitioned kdb+ databases – an equity options case study</fo:inline><fo:leader leader-pattern="space"/><fo:inline color="#0070cd" font-size="18pt" font-weight="bold" letter-spacing="-2pt">kx</fo:inline></fo:block></fo:static-content><fo:static-content flow-name="xsl-footnote-separator"><fo:block><fo:leader leader-pattern="rule" rule-thickness=".5pt" leader-length="50%"/></fo:block></fo:static-content><fo:static-content flow-name="xsl-region-after"><fo:block color="gray" text-align="right"><fo:inline font-family="Proxima Nova" font-size="9pt" letter-spacing="2pt"><fo:page-number/></fo:inline></fo:block></fo:static-content><fo:flow flow-name="xsl-region-body"><fo:block id="multi-partitioned-kdb-databases-an-equity-options-case-study">
  <fo:block id="idm133660856192" font-size="18pt" line-height="22pt" margin-right="36pt" page-break-before="always" space-after="60pt" text-align="left">Multi-partitioned kdb+ databases: an equity options case
  study</fo:block>
  <fo:block line-height="16pt" space-after="9pt" text-align="justify">
    Kdb+ is well suited to managing massive datasets and offers an
    unrivalled performance advantage when it comes to processing and
    analyzing data. This is a case study highlighting some of the key
    points we have found with regard to the storage and maintenance of
    financial equity options data in kdb+. We also provide some examples
    of possible ways to design and query these large databases
    efficiently.
  </fo:block>
  <fo:block id="overview-of-the-dataset">
    <fo:block id="idm133660854048" font-size="18pt" line-height="22pt" margin-right="36pt" page-break-before="always" space-after="60pt" text-align="left">Overview of the dataset</fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      The equity-options data universe is one of the largest financial
      datasets generated, and more often than not the most challenging
      dataset for trading firms to manage and extract value from in a
      timely manner. Hundreds of gigabytes of trade and quote records
      are published daily from the equity options feeds, with recent
      daily row count volumes for Q1 of 2012 having an average and
      maximum count close to 4 billion and 6 billion rows respectively.
      These numbers represent a relief of sorts from the peaks of 2011
      where we saw a maximum daily row count of over 13 billion as
      highlighted in the chart below.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      
        <fo:external-graphic content-width="scale-down-to-fit" src="url(img/image4.png)" width="100%"/>
      
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      The dataset we use for our examples in this paper includes level 1
      trade and quote data for financial options contracts, the
      associated reference data and the corresponding equity level 1
      trades and quotes for the same time period. All data has been
      sourced from tickdata.com.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      The sample dataset has a maximum of approximately 200 million rows
      for a single date and includes data for 10 underlying securities.
      The full universe that our clients load is typically much larger,
      covering thousands of underlying securities. For some of these
      securities, for example AAPL, the ratio of the number of option
      quotes to underlying quotes can be in excess of 60:1 on some
      dates.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      It is thus inevitable that when storing equity options data for a
      large universe of underlying securities, the number of rows per
      partition will regularly exceed 2 billion. When kdb+ 3.0 was
      released in 2011 it removed the limit to the number of rows that
      can be stored in a single partition. This gives us two options for
      storing massive tables, either storing each day of data in a
      single partition, or storing each day of data in multiple
      partitions.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      In this paper we cover the use of a multi partitioned database, as
      whilst kdb+ 3.0 allows the very straight forward option of having
      a single partition for each date, there are still potential
      advantages to the approach of storing data across multiple
      partitions for a single date.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      Firstly, when saving data, multiple partitions can be written
      concurrently, potentially reducing the time required to load data
      from flat files or persist it from memory. Secondly, when running
      queries against the database, data from multiple partitions can be
      read in parallel using slave threads. In the same way as queries
      on a database with a single partition per date can read data for
      multiple days in parallel, now data for the same date can be read
      in parallel. A third advantage related to database maintenance is
      that since the size of the individual column data files is
      reduced, the memory required to apply a sort to the data on disk
      will be reduced.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      Kdb+ provides a simple method to store the data in multiple
      partitions for each date by using the <fo:inline font-family="Pragmata Pro">par.txt</fo:inline>
      file. When attempting to read data from a database like this a
      large number of queries will behave exactly as they would in a
      database with only one partition per date. However there are some
      cases in which it’s necessary to rework things a little, most
      notably in the case of as-of joins. This is covered below.
    </fo:block>
  </fo:block>
  <fo:block id="options-schema">
    <fo:block id="idm133660845104" font-size="18pt" line-height="22pt" margin-right="36pt" page-break-before="always" space-after="60pt" text-align="left">Options schema</fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      Sorting and indexing the options data is straightforward. If we
      have the data sorted by underlying security, option contract and
      finally timestamp we can apply the partitioned attribute to both
      underlying security and option contract, allowing us to filter
      quickly on either column.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      More interesting is the way in which we choose to store the
      underlying security market data so that we can link it to the
      options data efficiently. The simplest way of accomplishing this
      would be to store the prevailing value of each underlying
      alongside the option trades and quote data. These extra columns
      would either be provided in the source data (as was the case in
      our sample dataset) or could be pre-calculated with an as-of join
      and then stored.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      The advantage of this method is that we do not need to store any
      additional underlying market data and there is no overhead when
      performing lookups to find the prevailing underlying quote or last
      trade for an option quote or trade. However there are two obvious
      downsides to using this approach.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      The first is that it does not offer any flexibility with regard to
      how the market data for an underlying security maps to the
      corresponding option data, e.g. if we wanted to do a window join
      to look at multiple underlying quotes surrounding each option
      quote. The second is that a significant amount of extra storage
      space will be required when the data is de-normalized in this way
      compared to storing the underlying market data in separate tables
      and doing joins on demand. Even with a frugal schema for the
      underlying data, this might add 40-50 bytes of storage for each
      record (depending on whether condition code and exchange fields
      can be stored as single characters or symbols are required for
      example). Given that there will be billions of option quotes per
      day, this can add hundreds of gigabytes to the daily storage
      requirements. It is worth noting that this may not be as large a
      problem as it first appears given the possibilities for data
      compression.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      A second possibility is to store underlying market data as
      completely separate tables and do any joins we require between the
      two datasets on a purely ad-hoc basis. This option offers the
      lightest storage requirements and also gives us full flexibility
      in how we do the joins. It does, however, come with the cost of
      extra processing time when searching for the underlying market
      data related to the option data at query time. Examples of how
      this is done can be found in the queries section below.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      A third option, a combination of the first two, would be to save
      the option and underlying data as separate tables, but to compute
      row indices in the underlying market data tables and store them in
      the option tables as link columns. This requires less space (a
      single integer column per link to each underlying table) than
      storing full underlying trade/quote information along with each
      option table row, avoids having to find the correct underlying
      trade/quote at query time and also gives flexibility by having all
      the underlying data available for ad-hoc joins.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      Using the third option requires us to ensure that the underlying
      and option data for the same securities always reside in the same
      partition. We can achieve this as part of the load process
      outlined below.
    </fo:block>
  </fo:block>
  <fo:block id="loading-and-saving-data">
    <fo:block id="idm133660838720" font-size="18pt" line-height="22pt" margin-right="36pt" page-break-before="always" space-after="60pt" text-align="left">Loading and saving data</fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      Here we assume some familiarity with loading large data files by
      splitting the file and loading in chunks using
      <fo:inline font-family="Pragmata Pro">.Q.fs</fo:inline> and <fo:inline font-family="Pragmata Pro">.Q.fsn</fo:inline>.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      <fo:inline font-family="Material Icons" font-size="14pt"></fo:inline>
      <fo:basic-link external-destination="url('http://code.kx.com/q/cookbook/')"><fo:inline color="#0070cd">Cookbook</fo:inline></fo:basic-link><fo:footnote><fo:inline font-size="8pt" alignment-baseline="hanging">1</fo:inline><fo:footnote-body><fo:block font-size="8pt">1.
									http://code.kx.com/q/cookbook/</fo:block></fo:footnote-body></fo:footnote>
    </fo:block>
    <fo:block id="striping-data-over-multiple-partitions-per-date">
      <fo:block font-weight="bold" font-size="14pt" line-height="17pt" margin-right="36pt" page-break-after="avoid" space-after="6pt" space-before="18pt" text-align="left">Striping data over multiple partitions per date</fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        Firstly we demonstrate how to save a chunk of loaded and parsed
        data into a database with multiple partitions per date. In our
        case we will split the data alphabetically by underlying symbol
        into groups as follows: ABC, DEF, GHI, JKL, MNO, PQR, STU and
        VWXYZ
      </fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        We should have a <fo:inline font-family="Pragmata Pro">par.txt</fo:inline> file containing
        paths to directories for each of these symbol groups. The
        contents of our <fo:inline font-family="Pragmata Pro">par.txt</fo:inline> file are thus as
        follows:
      </fo:block>
      <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
/data/0
/data/1
/data/2
/data/3
/data/4
/data/5
/data/6
/data/7
</fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        Before demonstrating how we can stripe the data over these
        directories, it is worth noting that if future data volumes
        increase and we wish to partition the data into a greater number
        of stripes, we can do this by adding new directories to
        <fo:inline font-family="Pragmata Pro">par.txt</fo:inline> without the need to go back and
        repartition old data. We would only need to create empty tables
        for each existing date for each partitioned table in our db.
      </fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        With regard to saving a chunk of data, there are many ways to do
        this but we provide an example below where we read in a list of
        available partitions and create some helper functions to allow
        us to easily partition and save the data. In the code below the
        directory is assumed to be a global variable
        (<fo:inline font-family="Pragmata Pro">DIR</fo:inline>) giving the path to our
        <fo:inline font-family="Pragmata Pro">par.txt</fo:inline> file in q format (symbol with a
        leading colon).
      </fo:block>
      <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
// A dictionary mapping alphabetical group to the directory
// in the database we wish to save to
dirs:`ABC`DEF`GHI`JKL`MNO`PQR`STU`VWXYZ!hsym each`$read0 ` sv DIR,`par.txt

// A function which will return a list of partitions
// to which each of a list of symbols should be saved.
getpart:.Q.fu {[symlist]
  key[dirs]0 3 6 9 12 15 18 21 bin .Q.A?first each string symlist,()}

saveonepart:{[dt;tablename;data;part2save]
  (` sv dirs[part2save],(`$string dt),tablename,`)set 
  .Q.en[DIR]
  delete part from select from data where part=part2save}
</fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        We could use the following snippet to save some quote data
        stored in a variable <fo:inline font-family="Pragmata Pro">CHUNK</fo:inline> inside a function
        called by <fo:inline font-family="Pragmata Pro">.Q.fs</fo:inline> or <fo:inline font-family="Pragmata Pro">.Q.fsn</fo:inline>.
        <fo:inline font-family="Pragmata Pro">DATE</fo:inline> is assumed to be a global variable here
        representing the date for which we are loading data. It is
        elementary to modify this to include the possibility of data for
        more than one date in a particular file load. This is excluded
        here for the sake of simplicity.
      </fo:block>
      <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
{
…
CHUNK:update part:getpart underlyingSym from CHUNK;
saveonepart[DATE;`QUOTE;CHUNK]each distinct exec part from CHUNK;
…
}
</fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        By implementing the previously-defined
        <fo:inline font-family="Pragmata Pro">getpart</fo:inline> function to generate the partition to
        save down to based on either the
        <fo:inline font-family="Pragmata Pro">underlyingSym</fo:inline> column for options data or the
        <fo:inline font-family="Pragmata Pro">sym</fo:inline> column for underlying market data, we can
        be sure that related options and underlying data will be stored
        in the same partitions.
      </fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        Once the data has been loaded and saved we will often need to
        apply an attribute to one or more of the columns of the data.
        This is a fairly easy step as we just need to apply the
        attribute to a table spread over multiple directories instead of
        one. In our example of option quotes we would like to apply the
        <fo:inline font-style="italic">partitioned</fo:inline> attribute
        (<fo:inline font-family="Pragmata Pro">`p#</fo:inline>) to both the <fo:inline font-family="Pragmata Pro">sym</fo:inline> and
        <fo:inline font-family="Pragmata Pro">underlyingSym</fo:inline> columns. We can do this as
        follows:
      </fo:block>
      <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
// function applies p# attribute to sym and underlyingSym columns
// of the quote table for the specified date and directory
addphashes:{[dt;dir]
  {[dt;dir;f]@[` sv dir,(`$string dt),`QUOTE;f;`p#]}[dt;dir]
  each `sym`underlyingSym} 
</fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        This may be called after loading all the data in our script:
      </fo:block>
      <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
addphashes[DATE]each value dirs;
</fo:block>
    </fo:block>
    <fo:block id="adding-links-to-market-data">
      <fo:block font-weight="bold" font-size="14pt" line-height="17pt" margin-right="36pt" page-break-after="avoid" space-after="6pt" space-before="18pt" text-align="left">Adding links to market data</fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        If we wish to store links to the underlying data within the
        option data, a sensible time to generate and store these links
        would be just after we have loaded, sorted and added attributes
        to the data. We can do this as part of a loader script with the
        following code. Here we just create one link stored in the
        <fo:inline font-family="Pragmata Pro">QUOTE</fo:inline> table to the corresponding quote in the
        <fo:inline font-family="Pragmata Pro">EQUOTE</fo:inline> (underlying quote) table:
      </fo:block>
      <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
dirs: `$read0 ` sv DIR,`par.txt 
addlinks:{[dt;dir]
  dir:` sv dir,`$string dt;
  // compute links as an as-of join. 
  inds:select ind: x from
  aj[`sym`timestamp;
    select sym:underlyingSym,timestamp from dir`QUOTE; 
    select sym,timestamp,i from dir`EQUOTE];
  // save the links
  (` sv dir,`QUOTE`underlying)set `EQUOTE!exec ind from inds;
  // update the metadata of the QUOTE table
  u set distinct get[u:` sv dir,`QUOTE`.d],`underlying}
</fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        Again we should use this for each partition for the date we have
        just loaded.
      </fo:block>
      <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
addlinks[DATE]each value dirs;
</fo:block>
    </fo:block>
  </fo:block>
  <fo:block id="example-queries">
    <fo:block id="idm133660812640" font-size="18pt" line-height="22pt" margin-right="36pt" page-break-before="always" space-after="60pt" text-align="left">Example queries</fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      In all of the examples below variables in caps are used instead of
      specific values.
    </fo:block>
    <fo:block id="raw-options-quote-data-retrieval-with-underlying-quote">
      <fo:block font-weight="bold" font-size="14pt" line-height="17pt" margin-right="36pt" page-break-after="avoid" space-after="6pt" space-before="18pt" text-align="left">Raw options quote data retrieval with underlying
      quote</fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        In the simplest case where we have the prevailing underlying
        quote stored alongside the option quote as columns
        <fo:inline font-family="Pragmata Pro">lastbidPrice</fo:inline> and
        <fo:inline font-family="Pragmata Pro">lastaskPrice</fo:inline> our query is:
      </fo:block>
      <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
select sym, timestamp, bidPrice, askPrice, lastBidPrice, lastAskPrice from QUOTE
  where date=DATE, sym=SYM, time within (STARTTIME;ENDTIME)
</fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        For the dataset where we have links to the prevailing underlying
        quote stored we can use:
      </fo:block>
      <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
select sym, timestamp, bidPrice, askPrice, underlying.bid, underlying.ask from QUOTE 
  where date=DATE, sym=SYM, time within (STARTTIME;ENDTIME)
</fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        In the case where we have the options data and underlying data
        stored in separate tables, we could usually use an as-of join.
        However, since our database has multiple partitions per date,
        specifying the right-most argument of the as-of join in the
        usual way does not behave in the same manner as in the case of
        databases with a single partition per date. For example, if we
        look at a standard query to get the prevailing quote as of each
        trade we encounter some problems.
      </fo:block>
      <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
aj[`sym`time;
  select price from TRADE where date=SOMEDATE, sym in SYMLIST; 
  select sym, time, bid, ask from quote where date=SOMEDATE]
</fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        In the case of a database with a single partition per date, this
        as-of join does not read the entire sym, time, bid and ask
        columns into memory before performing the lookup, rather it
        searches for the correct rows from a memory map of the quote
        table. In a database with multiple partitions per date, the
        following part of the previous query proves problematic:
      </fo:block>
      <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
select sym, time, bid, ask from EQUOTE where date=SOMEDATE
</fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        This now causes all of the data to be mapped and read into
        memory so that the as-of join can be performed. Not only is this
        undesirable due to the extra I/O required but because multiple
        memory-mapped partitions are being collapsed into one in memory
        table, it also has the detrimental side effect of removing the
        partitioned attribute normally found on the
        <fo:inline font-family="Pragmata Pro">sym</fo:inline> column since rows with the same symbol
        could occur in multiple partitions. This is not something that
        should actually occur in this database but since it is possible,
        kdb+ will defensively remove the partitioned attribute. In
        addition, because part of the reason we chose a database with
        multiple partitions for each date was to ensure no single
        partition was bigger than 2 billion rows, we may even hit a
        limit error when trying to do as-of joins against large tables.
        (This could only occur when using a version of kdb+ older than
        3.0).
      </fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        The result of the above is that not only would a join take
        longer because more data is being read from the disk but also
        the join itself will be performed much more slowly. A particular
        technique to work around this would be to create our own
        function which will perform joins against each memory-mapped
        partition for a certain date without reading the full table into
        memory, then aggregate the results from each partition.
      </fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        In the function below the parameters are specified as follows:
      </fo:block>
      <fo:table-and-caption margin-right="36pt" margin-bottom="9pt"><fo:table font-size="9pt"><fo:table-header border-bottom-style="solid" border-bottom-width=".5pt" page-break-after="avoid"><fo:table-row><fo:table-cell font-style="italic" padding-bottom="3pt" padding-left="5pt" padding-right="5pt"><fo:block linefeed-treatment="preserve" text-align="left">
                parameter
              </fo:block></fo:table-cell><fo:table-cell font-style="italic" padding-bottom="3pt" padding-left="5pt" padding-right="5pt"><fo:block linefeed-treatment="preserve" text-align="left">
                denotes
              </fo:block></fo:table-cell></fo:table-row></fo:table-header><fo:table-body><fo:table-row page-break-inside="avoid"><fo:table-cell padding-top="3pt" padding-bottom="3pt" padding-left="5pt" padding-right="5pt"><fo:block text-align="left">
                c
              </fo:block></fo:table-cell><fo:table-cell padding-top="3pt" padding-bottom="3pt" padding-left="5pt" padding-right="5pt"><fo:block text-align="left">
                A list of column names upon which to perform the as-of
                join, just as we would have with a regular
                <fo:inline font-family="Pragmata Pro">aj</fo:inline>
              </fo:block></fo:table-cell></fo:table-row><fo:table-row page-break-inside="avoid"><fo:table-cell padding-top="3pt" padding-bottom="3pt" padding-left="5pt" padding-right="5pt"><fo:block text-align="left">
                t1
              </fo:block></fo:table-cell><fo:table-cell padding-top="3pt" padding-bottom="3pt" padding-left="5pt" padding-right="5pt"><fo:block text-align="left">
                The first table, just as in the case of a regular
                <fo:inline font-family="Pragmata Pro">aj</fo:inline>
              </fo:block></fo:table-cell></fo:table-row><fo:table-row page-break-inside="avoid"><fo:table-cell padding-top="3pt" padding-bottom="3pt" padding-left="5pt" padding-right="5pt"><fo:block text-align="left">
                t2
              </fo:block></fo:table-cell><fo:table-cell padding-top="3pt" padding-bottom="3pt" padding-left="5pt" padding-right="5pt"><fo:block text-align="left">
                The second table name, a symbol giving the name of a
                partitioned table. (To do an as-of join on a
                non-partitioned table, use a regular
                <fo:inline font-family="Pragmata Pro">aj</fo:inline>.)
              </fo:block></fo:table-cell></fo:table-row><fo:table-row page-break-inside="avoid"><fo:table-cell padding-top="3pt" padding-bottom="3pt" padding-left="5pt" padding-right="5pt"><fo:block text-align="left">
                t2d
              </fo:block></fo:table-cell><fo:table-cell padding-top="3pt" padding-bottom="3pt" padding-left="5pt" padding-right="5pt"><fo:block text-align="left">
                The date upon which to do the join. (Do one date at a
                time if there are multiple dates.)
              </fo:block></fo:table-cell></fo:table-row><fo:table-row page-break-inside="avoid"><fo:table-cell padding-top="3pt" padding-bottom="3pt" padding-left="5pt" padding-right="5pt"><fo:block text-align="left">
                t2c
              </fo:block></fo:table-cell><fo:table-cell padding-top="3pt" padding-bottom="3pt" padding-left="5pt" padding-right="5pt"><fo:block text-align="left">
                A list of column expressions for the selection from the
                partitioned table, e.g.
                <fo:inline font-family="Pragmata Pro">(`Ticker;`Timestamp;`Trade;`TradeSize;(log;`TradeSize))</fo:inline>
                – usually some subset of the column names in the table
              </fo:block></fo:table-cell></fo:table-row><fo:table-row page-break-inside="avoid"><fo:table-cell padding-top="3pt" padding-bottom="3pt" padding-left="5pt" padding-right="5pt"><fo:block text-align="left">
                t2cn
              </fo:block></fo:table-cell><fo:table-cell padding-top="3pt" padding-bottom="3pt" padding-left="5pt" padding-right="5pt"><fo:block text-align="left">
                A list of column aliases in the partitioned table e.g.
                <fo:inline font-family="Pragmata Pro">`Ticker`Timestamp`price`size`lnprice</fo:inline>
              </fo:block></fo:table-cell></fo:table-row></fo:table-body></fo:table></fo:table-and-caption>
      <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
ajparted:{[c;t1;t2n;t2d;t2c;t2cn] 
  if[not all c in t2cn;'`missingcols];
  / we want just one row per row in the input, so put a row id as a key
  / and just fill values in the input table with
  / rows that are found for the second table
  / build table a table with the right schema to start 
  t1:`rid xkey update rid:`s#i from 
    aj[c;t1;?[t2n;enlist(&lt;;`date;first date);0b;t2cn!t2c]];
  / do aj's on each partition of the second table with the first table,
  / only return rows that we have values for,
  / then upsert these to the keyed t1 
  delete rid from 0!t1,/
    {[c;t1;t2n;t2d;t2c;t2cn;x] 
      inds@:vinds:where not null inds:
        (c#M:?[(` sv`$string x,t2d)t2n;();0b;t2cn!t2c])bin (c#value t1); 
      1!(0!t1)[vinds],'M inds}[c;t1;t2n;t2d;t2c;t2cn]
  peach distinct .Q.pd}
</fo:block>
      <fo:block line-height="16pt" space-after="9pt" text-align="justify">
        Returning to our original example query of getting the
        prevailing underlying quote information for a particular set of
        option quotes, we can use the following call to the
        <fo:inline font-family="Pragmata Pro">ajparted</fo:inline> function:
      </fo:block>
      <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
t1: select sym,timestamp,bidPrice,askPrice from QUOTE 
  where date=SOMEDATE,sym in SYMLIST,timestamp within (STARTTIME:ENDTIME)

ajparted[`underlyingSym`timestamp;t1;`EQUOTE;SOMEDATE;
  `sym`timestamp`bid`ask;`underlyingSym`timestamp`bid`ask]
</fo:block>
    </fo:block>
  </fo:block>
  <fo:block id="snapshot-of-option-chain">
    <fo:block id="idm133660782608" font-size="18pt" line-height="22pt" margin-right="36pt" page-break-before="always" space-after="60pt" text-align="left">Snapshot of option chain</fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      This is an example where we have an underlying symbol and want to
      get a snapshot of the quotes available for all options at a given
      time.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      Firstly, we will need to query the security master table (called
      <fo:inline font-family="Pragmata Pro">mas</fo:inline> in our case) for all option data available
      on the given date for this underlying and then find the last quote
      available for each option at, or prior to, the given time.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      The available option contracts may be queried from a security
      master table, <fo:inline font-family="Pragmata Pro">mas</fo:inline>, using the following:
    </fo:block>
    <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
optsyms:select sym from mas 
  where date=OURDATE, underlyingSym=OURSYM
</fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      Now that we have all of the options contracts we require, the
      question becomes how to query the <fo:inline font-family="Pragmata Pro">QUOTE</fo:inline> table
      to get the available quote for each option at the given time. One
      way to do this would be to write a query to extract the last quote
      prior to the time in question for each option:
    </fo:block>
    <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
select last bid, last ask by sym from QUOTE 
  where date=OURDATE, sym in optsyms, time&lt;=OURTIME
</fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      However, this is another place where we would normally use an
      as-of join since it allows us to efficiently search for the last
      record prior to the time in question rather than scan through all
      of the records for each symbol to see if the timestamp constraint
      is fulfilled. We can use the same function from the previous
      example to do an as-of join here. Firstly, we use the
      <fo:inline font-family="Pragmata Pro">cross</fo:inline> function to create a table of symbol and
      time pairs in order to carry out the as-of join:
    </fo:block>
    <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
rack:optsyms cross ([]timestamp:1#OURTIME)
</fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      Now we can use <fo:inline font-family="Pragmata Pro">ajparted</fo:inline> to find the correct
      rows from the <fo:inline font-family="Pragmata Pro">QUOTE</fo:inline> table
    </fo:block>
    <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
ajparted[`sym`timestamp;rack;`QUOTE;OURDATE;
  `sym`timestamp`bid`ask;`sym`timestamp`bid`ask]
</fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      In the previous example we were able to avoid an ad-hoc as-of join
      provided we had underlying data (or pre-calculated links to it)
      stored alongside the options quote data. In this case however, we
      will need to use an as-of join regardless of how the data is
      stored.
    </fo:block>
  </fo:block>
  <fo:block id="building-a-minutely-time-series-of-at-the-money-option-contracts">
    <fo:block id="idm133660771584" font-size="18pt" line-height="22pt" margin-right="36pt" page-break-before="always" space-after="60pt" text-align="left">Building a minutely time series of at-the-money option
    contracts</fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      In our final example, we demonstrate the creation of a minutely
      time series based on the idea of a generic option contract. In
      this case we choose a condition specifying this contract as the
      next expiring call contract nearest to at-the-money.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      Initially, we create a time series of minutely bars for the
      underlying symbol so we can determine which actual option contract
      we should use at each point. Given we are working with relatively
      low-volume trade data, we do this with a regular grouping and
      aggregation query. Note that we could also use
      <fo:inline font-family="Pragmata Pro">ajparted</fo:inline> with a rack of symbol and time pairs
      as in the above example.
    </fo:block>
    <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
bars:select last price by time.minute from ETRADE 
  where date=ourdate, sym=OURSYM
</fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      We now need to find the particular contracts that are available on
      our chosen date and the one that is closest to at-the-money at
      each point in our series.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      We can wrap up the logic for choosing a contract into a function
      with parameters for date, underlying security, contract type (call
      or put) and price:
    </fo:block>
    <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
closest2atm:{[d;s;t;p]
/ A list of all the nearest expiring contracts on this date
cands:`strike xasc select sym,strike from mas
  where date=d, underlyingSym=s, typ=t, expir=(min;expir)fby underlyingSym;
  / A list of all strike prices with midpoints between,
  / we can then use bin to find the contract with a strike price to our prices 
  searchlist:1_raze{avg[x,y],x}':[cands`strike];
  inds:searchlist bin p;
  / Any odd indices in inds mean price is closer to strike above
  / add one to these and divide everything by 2 to give the indices into cands
  inds[where 1=inds mod 2]+:1;
  inds:inds div 2;
  / return the list of at-the-money symbols 
  cands[`sym]inds}

update sym:closest2atm[OURDATE;OURSYM;"C";price] from `bars
</fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      Finally we query the closing bid and ask for each of these bars:
    </fo:block>
    <fo:block font-family="Pragmata Pro" font-size="10pt" margin-bottom="12pt" margin-left="10pt" page-break-inside="avoid" white-space="pre">
ajparted[
  `sym`timestamp;
  select sym, minute, timestamp:`timespan$minute, price from bars;
  `QUOTE; OURDATE;
  `sym`timestamp`bid`ask; `sym`timestamp`bid`ask]
</fo:block>
  </fo:block>
  <fo:block id="compression">
    <fo:block id="idm133660764912" font-size="18pt" line-height="22pt" margin-right="36pt" page-break-before="always" space-after="60pt" text-align="left">Compression</fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      The use of compression for all or part of the dataset here is
      outside the scope of this whitepaper, however, this is undoubtedly
      an important feature to consider using for options data.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      <fo:inline font-family="Material Icons" font-size="14pt"></fo:inline> Cookbook:
      <fo:basic-link external-destination="url('http://code.kx.com/q/cookbook/file-compression/')"><fo:inline color="#0070cd">File
      compression</fo:inline></fo:basic-link><fo:footnote><fo:inline font-size="8pt" alignment-baseline="hanging">2</fo:inline><fo:footnote-body><fo:block font-size="8pt">2.
									http://code.kx.com/q/cookbook/file-compression/</fo:block></fo:footnote-body></fo:footnote>
    </fo:block>
  </fo:block>
  <fo:block id="conclusion">
    <fo:block id="idm133660761600" font-size="18pt" line-height="22pt" margin-right="36pt" page-break-before="always" space-after="60pt" text-align="left">Conclusion</fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      Storing and querying options data can present challenges due to
      the volume of data involved. While the introduction of kdb+ 3.0
      lets clients easily handle the ever-increasing data volumes by
      removing the per-partition limit of 2 billion rows, there are
      still several potential benefits to storing the tick data in
      multiple partitions per date as outlined in <fo:inline font-style="italic">Overview of
      the dataset</fo:inline>. As we have seen however, in choosing this
      approach it will be necessary to write some queries in a different
      way to achieve the best performance.
    </fo:block>
    <fo:block line-height="16pt" space-after="9pt" text-align="justify">
      Regardless of whether the data is stored in a single partition per
      date or in a multi-partitioned manner, the choice of schema will
      still impact the storage space required for the data and queries
      against the database. Here we have presented several different
      schema choices and examples of several simple queries implemented
      for each schema.
    </fo:block>
    
  </fo:block>
</fo:block></fo:flow></fo:page-sequence></fo:root>
