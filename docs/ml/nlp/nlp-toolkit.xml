<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article>
<article
  xmlns="http://docbook.org/ns/docbook" version="5.0"
  xmlns:xlink="http://www.w3.org/1999/xlink" >
  <info>
    <title>Natural-language processing toolkit</title>
    <authorgroup>
      <author>
        <firstname>Fionnuala</firstname>
        <surname>Carr</surname>
      </author>
    </authorgroup>
    <date>May 2018</date>
    <keywords>machine learning, ml, nlp, sentiment analysis</keywords>
  </info>
<section xml:id="natural-language-processing">
  <title>Natural-language processing</title>
  <para>
    Natural-language processing (NLP) can be used to answer a variety of
    questions about unstructured text data, as well as facilitating
    open-ended exploration.
  </para>
  <para>
    It can be applied to datasets such as emails, online articles and
    comments, tweets, or novels. Although the source is text,
    transformations are applied to convert this data to vectors,
    dictionaries and symbols which can be handled very effectively by q.
    Many operations such as searching, clustering, and keyword
    extraction can all be done using very simple data structures, such
    as feature vectors and bag-of-words representations.
  </para>
</section>
<section xml:id="preparing-text">
  <title>Preparing text</title>
  <para>
    Operations can be pre-run on a corpus, with the results cached to a
    table, which can be persisted.
  </para>
  <para>
    Operations undertaken to parse the dataset:
  </para>
  <informaltable>
    <tgroup cols="2">
      <colspec colwidth="32*" align="left" />
      <colspec colwidth="67*" align="left" />
      <thead>
        <row>
          <entry>
            operation
          </entry>
          <entry>
            effect
          </entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
            Tokenization
          </entry>
          <entry>
            splits the words; e.g. <literal>John’s</literal> becomes
            <literal>John</literal> as one token, and
            <literal>‘s</literal> as a second
          </entry>
        </row>
        <row>
          <entry>
            Sentence detection
          </entry>
          <entry>
            characters at which a sentence starts and ends
          </entry>
        </row>
        <row>
          <entry>
            Part of speech tagger
          </entry>
          <entry>
            parses the sentences into tokens and gives each token a
            label e.g. <literal>lemma</literal>, <literal>pos</literal>,
            <literal>tag</literal> etc.
          </entry>
        </row>
        <row>
          <entry>
            Lemmatization
          </entry>
          <entry>
            converts to a base form e.g. <literal>ran</literal> (verb)
            to <literal>run</literal> (verb)
          </entry>
        </row>
      </tbody>
    </tgroup>
  </informaltable>
  <section xml:id="nlp.newparser">
    <title><literal>.nlp.newParser</literal></title>
    <para>
      <emphasis>Creates a parser</emphasis>
    </para>
    <para>
      Syntax: <literal>.nlp.newParser[spacymodel;fields]</literal>
    </para>
    <para>
      Where
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <literal>spacymodel</literal> is a
          <link xlink:href="https://spacy.io/usage/models">model or
          language</link> (symbol)
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>fields</literal> is the field/s you want in the
          output (symbol atom or vector)
        </para>
      </listitem>
    </itemizedlist>
    <para>
      returns a function to parse the text.
    </para>
    <para>
      The optional fields are:
    </para>
    <informaltable>
      <tgroup cols="3">
        <colspec align="left" />
        <colspec align="left" />
        <colspec align="left" />
        <thead>
          <row>
            <entry>
              field
            </entry>
            <entry>
              type
            </entry>
            <entry>
              content
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <literal>text</literal>
            </entry>
            <entry>
              list of characters
            </entry>
            <entry>
              original text
            </entry>
          </row>
          <row>
            <entry>
              <literal>tokens</literal>
            </entry>
            <entry>
              list of symbols
            </entry>
            <entry>
              the tokenized text
            </entry>
          </row>
          <row>
            <entry>
              <literal>sentChars</literal>
            </entry>
            <entry>
              list of lists of longs
            </entry>
            <entry>
              indexes of start and end of sentences
            </entry>
          </row>
          <row>
            <entry>
              <literal>sentIndices</literal>
            </entry>
            <entry>
              list of integers
            </entry>
            <entry>
              indexes of the first token of each sentences
            </entry>
          </row>
          <row>
            <entry>
              <literal>pennPOS</literal>
            </entry>
            <entry>
              list of symbols
            </entry>
            <entry>
              the Penn Treebank tagset
            </entry>
          </row>
          <row>
            <entry>
              <literal>uniPOS</literal>
            </entry>
            <entry>
              list of symbols
            </entry>
            <entry>
              the Universal tagset
            </entry>
          </row>
          <row>
            <entry>
              <literal>lemmas</literal>
            </entry>
            <entry>
              list of symbols
            </entry>
            <entry>
              the base form of the word
            </entry>
          </row>
          <row>
            <entry>
              <literal>isStop</literal>
            </entry>
            <entry>
              boolean
            </entry>
            <entry>
              is the token part of the stop list?
            </entry>
          </row>
          <row>
            <entry>
              <literal>likeEmail</literal>
            </entry>
            <entry>
              boolean
            </entry>
            <entry>
              does the token resembles an email?
            </entry>
          </row>
          <row>
            <entry>
              <literal>likeURL</literal>
            </entry>
            <entry>
              boolean
            </entry>
            <entry>
              does the token resembles a URL?
            </entry>
          </row>
          <row>
            <entry>
              <literal>likeNumber</literal>
            </entry>
            <entry>
              boolean
            </entry>
            <entry>
              does the token resembles a number?
            </entry>
          </row>
          <row>
            <entry>
              <literal>keywords</literal>
            </entry>
            <entry>
              list of dictionaries
            </entry>
            <entry>
              significance of each term
            </entry>
          </row>
          <row>
            <entry>
              <literal>starts</literal>
            </entry>
            <entry>
              long
            </entry>
            <entry>
              index that a token starts at
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>
      The resulting function is applied to a list of strings.
    </para>
    <para>
      Parsing the novel <emphasis>Moby Dick</emphasis>:
    </para>
    <programlisting language="r script">
/ creating a parsed table  
fields:`text`tokens`lemmas`pennPOS`isStop`sentChars`starts`sentIndices`keywords
myparser:.nlp.newParser[`en;fields] 
corpus:myparser mobyDick 
cols corpus
`tokens`lemmas`pennPOS`isStop`sentChars`starts`sentIndices`keywords`text
</programlisting>
  </section>
  <section xml:id="finding-part-of-speech-tags-in-a-corpus">
    <title>Finding part-of-speech tags in a corpus</title>
    <para>
      This is a quick way to find all of the nouns, adverbs, etc. in a
      corpus. There are two types of part-of-speech (POS) tags you can
      find:
      <link xlink:href="https://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html">Penn
      Tree tags</link> and
      <link xlink:href="http://universaldependencies.org/docs/en/pos/all.html">Universal
      Tree tags</link>.
    </para>
    <section xml:id="nlp.findposruns">
      <title><literal>.nlp.findPOSRuns</literal></title>
      <para>
        <emphasis>Runs of tokens whose POS tags are in the set
        passed</emphasis>
      </para>
      <para>
        Syntax:
        <literal>.nlp.findPOSRuns[tagtype;tags;document]</literal>
      </para>
      <para>
        Where
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>tagtype</literal> is <literal>uniPos</literal> or
            <literal>pennPos</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>tags</literal> is one or more POS tags (symbol atom
            or vector)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>document</literal> is parsed text (dictionary)
          </para>
        </listitem>
      </itemizedlist>
      <para>
        returns a general list:
      </para>
      <orderedlist numeration="arabic" spacing="compact">
        <listitem>
          <para>
            text of the run (symbol vector)
          </para>
        </listitem>
        <listitem>
          <para>
            indexes of the first occurrence of each token (long vector)
          </para>
        </listitem>
      </orderedlist>
      <para>
        Importing a novel from a plain text file, and finding all the
        proper nouns in the first chapter of <emphasis>Moby
        Dick</emphasis>:
      </para>
      <programlisting language="r script">
fields:`text`tokens`lemmas`pennPOS`isStop`sentChars`starts`sentIndices`keywords
q)myparser:.nlp.parser.i.newParser[`en;fields] 
q)corpus:myparser mobyDick 

q).nlp.findPOSRuns[`pennPOS;`NNP`NNPS;corpus 0][;0]
`loomings`ishmael`november`cato`manhattoes`circumambulate`sabbath`go`corlears`hook`coenties
</programlisting>
    </section>
  </section>
</section>
<section xml:id="feature-vectors">
  <title>Feature vectors</title>
  <para>
    We can generate a dictionary of descriptive terms, which consist of
    terms and their associated weights. These dictionaries are called
    <emphasis>feature vectors</emphasis> and they are very useful as
    they give a uniform representation that can describe words,
    sentences, paragraphs, documents, collections of documents,
    clusters, concepts and queries.
  </para>
  <section xml:id="calculating-feature-vectors-for-documents">
    <title>Calculating feature vectors for documents</title>
    <para>
      The values associated with each term in a feature vector are how
      significant that term is as a descriptor of the entity. For
      documents, this can be calculated by comparing the frequency of
      words in that document to the frequency of words in the rest of
      the corpus.
    </para>
    <para>
      Sorting the terms in a feature vector by their significance, you
      get the keywords that distinguish a document most from the corpus,
      forming a terse summary of the document. This shows the most
      significant terms in the feature vector for one of Enron CEO Jeff
      Skilling’s email’s describing a charity bike ride.
    </para>
    <para>
      TF-IDF is an algorithm that weighs a term’s frequency (TF) and its
      inverse document frequency (IDF). Each word or term has its
      respective TF and IDF score. The product of the TF and IDF scores
      of a term is called the TF-IDF weight of that term.
    </para>
    <section xml:id="nlp.tfidf">
      <title><literal>.nlp.TFIDF</literal></title>
      <para>
        <emphasis>TF-IDF scores for all terms in the document</emphasis>
      </para>
      <para>
        Syntax: <literal>.nlp.TFIDF x</literal>
      </para>
      <para>
        Where <literal>x</literal> is a table of documents, returns for
        each document, a dictionary with the tokens as keys, and
        relevance as values.
      </para>
      <para>
        Extract a specific document and find the most significiant words
        in that document:
      </para>
      <programlisting language="r script">
q)queriedemail:jeffcorpus[where jeffcorpus[`text] like &quot;*charity bike*&quot;]`text;
q)5#desc .nlp.TFIDF[jeffcorpus]1928
bikers   | 17.7979
biker    | 17.7979
strenuous| 14.19154
route    | 14.11932
rode     | 14.11136
</programlisting>
      <para>
        In cases where the dataset is more similar to a single document
        than a collection of separate documents, a different algorithm
        can be used. This algorithm is taken from Carpena, P., et al.
        <quote>Level statistics of words: Finding keywords in literary
        texts and symbolic sequences.</quote>. The idea behind the
        algorithm is that more important words occur in clusters and
        less important words follow a random distribution.
      </para>
    </section>
    <section xml:id="nlp.keywordscontinuous">
      <title><literal>.nlp.keywordsContinuous</literal></title>
      <para>
        <emphasis>For an input which is conceptually a single document,
        such as a book, this will give better results than
        TF-IDF</emphasis>
      </para>
      <para>
        Syntax: <literal>.nlp.keywordsContinuous x</literal>
      </para>
      <para>
        Where <literal>x</literal> is a table of documents, returns a
        dictionary where the keys are keywords and the values are their
        significance.
      </para>
      <para>
        Treating all of <emphasis>Moby Dick</emphasis> as a single
        document, the most significant keywords are
        <emphasis>Ahab</emphasis>, <emphasis>Bildad</emphasis>,
        <emphasis>Peleg</emphasis> (the three captains on the boat) and
        <emphasis>whale</emphasis>.
      </para>
      <programlisting language="r script">
q)10#keywords:.nlp.keywordsContinuous corpus
ahab     | 65.23191
peleg    | 52.21875
bildad   | 46.56072
whale    | 42.72953
stubb    | 38.11739
queequeg | 35.34769
steelkilt| 33.96713
pip      | 32.90067
starbuck | 32.05286
thou     | 32.05231
</programlisting>
    </section>
  </section>
  <section xml:id="calculating-feature-vectors-for-words">
    <title>Calculating feature vectors for words</title>
    <para>
      The feature vector for a word can be calculated as a collection of
      how well other words predict the given keyword. The weight given
      to these words is a function of how much higher the actual
      co-occurrence rate is from the expected co-occurrence rate the
      terms would have if they were randomly distributed.
    </para>
    <section xml:id="nlp.findrelatedterms">
      <title><literal>.nlp.findRelatedTerms</literal></title>
      <para>
        <emphasis>Feature vector for a term</emphasis>
      </para>
      <para>
        Syntax: <literal>.nlp.findRelatedTerms[x;y]</literal>
      </para>
      <para>
        Where
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>x</literal> is a list of documents
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>y</literal> is a symbol which is the token for
            which to find related terms
          </para>
        </listitem>
      </itemizedlist>
      <para>
        returns a dictionary of the related tokens and their relevances.
      </para>
      <programlisting language="r script">
q).nlp.findRelated[corpus;`captain]
peleg | 1.653247
bildad| 1.326868
ahab  | 1.232073
ship  | 1.158671
cabin | 0.9743517
</programlisting>
      <para>
        Phrases can be found by looking for runs of words with an
        above-average significance to the query term.
      </para>
    </section>
    <section xml:id="nlp.extractphrases">
      <title><literal>.nlp.extractPhrases</literal></title>
      <para>
        <emphasis>Runs of tokens that contain the term where each
        consecutive word has an above-average co-occurrence with the
        term</emphasis>
      </para>
      <para>
        Syntax: <literal>.nlp.extractPhrases[corpus;term]</literal>
      </para>
      <para>
        Where
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>corpus</literal> is a subcorpus (table)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>term</literal> is the term to extract phrases
            around (symbol)
          </para>
        </listitem>
      </itemizedlist>
      <para>
        returns a dictionary with phrases as the keys and their
        relevance as the values.
      </para>
      <para>
        Search for the phrases that contain <literal>captain</literal>
        and see which phrase has the largest occurrence; we find
        <literal>captain ahab</literal> occurs most often in the book:
        31 times.
      </para>
      <programlisting language="r script">
q).nlp.extractPhrases[corpus;`captain]  
&quot;captain ahab&quot;        | 31
&quot;captain peleg&quot;       | 12
&quot;captain bildad&quot;      | 7
&quot;captain sleet&quot;       | 5
&quot;stranger captain&quot;    | 4
&quot;said the captain&quot;    | 3
&quot;sea-captain&quot;         | 2
&quot;whaling captain&quot;     | 2
&quot;captain's cabin&quot;     | 2
&quot;captain ahab,\&quot; said&quot;| 2
&quot;captain pollard&quot;     | 2
&quot;captain d'wolf&quot;      | 2
&quot;way, captain&quot;        | 2
</programlisting>
    </section>
  </section>
</section>
<section xml:id="comparisons">
  <title>Comparisons</title>
  <section xml:id="comparing-feature-vectors">
    <title>Comparing feature vectors</title>
    <para>
      A vector can be thought of either as
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          the co-ordinates of a point
        </para>
      </listitem>
      <listitem>
        <para>
          describing a line segment from the origin to a point
        </para>
      </listitem>
    </itemizedlist>
    <para>
      The view of a vector as a line segment starting at the origin is
      useful, as any two vectors will have an angle between them,
      corresponding to their similarity, as calculated by cosine
      similarity.
    </para>
    <para>
      The <emphasis>cosine similarity</emphasis> of two vectors is the
      dot product of two vectors over the product of their magnitudes.
      It is a standard distance metric for comparing documents.
    </para>
  </section>
  <section xml:id="comparing-corpora">
    <title>Comparing corpora</title>
    <para>
      A quick way to compare corpora is to find words common to the
      whole dataset, but with a strong affinity to only one corpus. This
      is a function of how much higher their frequency is in that corpus
      than in the dataset.
    </para>
    <section xml:id="nlp.comparecorpora">
      <title><literal>.nlp.compareCorpora</literal></title>
      <para>
        <emphasis>Terms’ comparative affinities to two
        corpora</emphasis>
      </para>
      <para>
        Syntax: <literal>.nlp.compareCorpora[corpus1;corpus2]</literal>
      </para>
      <para>
        Where <literal>corpus1</literal> and <literal>corpus2</literal>
        are tables of lists of documents, returns a dictionary of terms
        and their affinity for <literal>corpus2</literal> over
        <literal>corpus1</literal>.
      </para>
      <para>
        Enron CEO Jeff Skillings was a member of the Beta Theta Pi
        fraternity at Southern Methodist University (SMU). If we want to
        find secret fraternity code words used by the Betas, we can
        compare his fraternity emails (those containing
        <emphasis>SMU</emphasis> or <emphasis>Betas</emphasis>) to his
        other emails.
      </para>
      <programlisting language="r script">
q)fraternity:jeffcorpus i:where (jeffcorpus[`text] like &quot;*Betas*&quot;)|jeffcorpus[`text] like &quot;*SMU*&quot;
q)remaining:jeffcorpus til[count jeffcorpus]except i
q)summaries:key each 10#/:.nlp.compareCorpora[fraternity;remaining]
q)summaries 0  / summary of the fraternity corpus
`beta`homecoming`betas`smu`yahoo`groups`tent`reunion`forget`crowd
q)summaries 1  / summary of the remaining corpus
`enron`jeff`business`information`please`market`services`energy`management`company
</programlisting>
    </section>
  </section>
  <section xml:id="comparing-documents">
    <title>Comparing documents</title>
    <para>
      This function allows you to calculate the similarity of two
      different documents. It finds the keywords that are present in
      both the corporas, and calculates the cosine similarity.
    </para>
    <section xml:id="nlp.comparedocs">
      <title><literal>.nlp.compareDocs</literal></title>
      <para>
        <emphasis>Cosine similarity of two documents</emphasis>
      </para>
      <para>
        Syntax: <literal>.nlp.compareDocs[dict1;dict2]</literal>
      </para>
      <para>
        Where <literal>dict1</literal> and <literal>dict2</literal> are
        dictionaries that consist of the document‘s keywords, returns
        the cosine similarity of two documents.
      </para>
      <para>
        Given the queried email defined above, and a random email from
        the corpus, we can calculate the cosine similarity between them.
      </para>
      <programlisting language="r script">
q)queryemail2:jeffcorpus[rand count jeffcorpus]
q).nlp.compareDocs[queryemail`keywords;email2`keywords]
0.1163404
</programlisting>
    </section>
  </section>
  <section xml:id="comparing-documents-to-corpus">
    <title>Comparing documents to corpus</title>
    <section xml:id="nlp.comparedoctocorpus">
      <title><literal>.nlp.compareDocToCorpus</literal></title>
      <para>
        <emphasis>Cosine similarity between a document and other
        documents in the corpus</emphasis>
      </para>
      <para>
        Syntax: <literal>.nlp.compareDocToCorpus[keywords;idx]</literal>
      </para>
      <para>
        Where
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>keywords</literal> is a list of dictionaries of
            keywords and coefficients
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>idx</literal> is the index of the feature vector to
            compare with the rest of the corpus
          </para>
        </listitem>
      </itemizedlist>
      <para>
        returns as a float the document’s significance to the rest of
        the corpus.
      </para>
      <para>
        Comparing the first chapter with the rest of the book:
      </para>
      <programlisting language="r script">
q).nlp.compareDocToCorpus[corpus`keywords;0]
0.03592943 0.04720108 0.03166343 0.02691693 0.03363885 0.02942622 0.03097797 0.04085023 0.04321152 0.02024251 0.02312604 0.03604447 0.02903568 0.02761553 0.04809854 0.03634777 0.02755392 0.02300291
</programlisting>
    </section>
  </section>
</section>
<section xml:id="clustering">
  <title>Clustering</title>
  <para>
    The NLP library contains a variety of clustering algorithms, with
    different parameters and performance characteristics. Some of these
    are very fast on large data sets, though they look only at the most
    salient features of each document, and will create many small
    clusters. Others, such as bisecting k-means, look at all features
    present in the document, and allow you to specify the number of
    clusters. Other parameters can include a threshold for the minimum
    similarity to consider, or how many iterations the algorithm should
    take to refine the clusters. Some clustering algorithms are
    randomized, and will produce different clusters every time they are
    run. This can be very useful, as a data set will have many possible,
    equally valid, clusterings. Some algorithms will put every document
    in a cluster, whereas others will increase cluster cohesion by
    omitting outliers.
  </para>
  <para>
    Clusters can be summarized by their centroids, which are the sum of
    the feature vectors of all the documents they contain.
  </para>
  <section xml:id="markox-cluster-algorithm">
    <title>Markox Cluster algorithm</title>
    <para>
      MCL clustering, which takes document similarity as its only
      parameter other than the documents. This algorithm first generates
      an undirected graph of documents by classifying document pairs as
      related or unrelated, depending on whether their similarity
      exceeds a given threshold. If they are related, an edge will be
      created between these documents. Then it runs a graph-clustering
      algorithm on the dataset.
    </para>
    <section xml:id="nlp.cluster.mcl">
      <title><literal>.nlp.cluster.MCL</literal></title>
      <para>
        <emphasis>Cluster a subcorpus using graph clustering</emphasis>
      </para>
      <para>
        Syntax:
        <literal>.nlp.cluster.similarity[document;min;sample]</literal>
      </para>
      <para>
        Where
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>document</literal> is a table of documents
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>min</literal> is the minimum similarity (float)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>sample</literal> is whether a sample of
            <literal>sqrt[n]</literal> documents is to be used (boolean)
          </para>
        </listitem>
      </itemizedlist>
      <para>
        returns as a list of longs the document’s indexes, grouped into
        clusters.
      </para>
      <para>
        Cluster 2603 of Jeff Skillings emails, creating 398 clusters
        with the minimum threshold at 0.25:
      </para>
      <programlisting language="r script">
q)clusterjeff:.nlp.cluster.similarity[jeffcorpus;0.25;0b]
q)count clusterjeff
398
</programlisting>
    </section>
  </section>
  <section xml:id="summarizing-cluster-algorithm">
    <title>Summarizing Cluster algorithm</title>
    <para>
      This clustering algorithm finds the top ten keywords in each
      document, finds the average of these keywords and determines the
      top keyword. This is set to be the centroid and therefore finds
      the closest document. This process is repeated until the number of
      clusters are found.
    </para>
    <section xml:id="nlp.cluster.summarize">
      <title><literal>.nlp.cluster.summarize</literal></title>
      <para>
        <emphasis>A clustering algorithm that works like many
        summarizing algorithms, by finding the most representative
        elements, then subtracting them from the centroid and iterating
        until the number of clusters has been reached</emphasis>
      </para>
      <para>
        Syntax:
        <literal>.nlp.cluster.summarize[docs;noOfClusters]</literal>
      </para>
      <para>
        Where
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>docs</literal> is a list of documents or document
            keywords (table or list of dictionaries)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>noOfClusters</literal> is the number of clusters to
            return (long)
          </para>
        </listitem>
      </itemizedlist>
      <para>
        returns the documents’ indexes, grouped into clusters.
      </para>
      <programlisting language="r script">
q).nlp.cluster.summarize[jeffcorpus;30]

0 31 47 127 361 431 513 615 724 786 929 933 1058..
1 40 44 189 507 514 577 585 746 805 869 1042.. 
2 3 4 6 7 9 10 13 16 17 19 20 22 23 24 28 33 34..
5 27 30 39 393 611 641 654 670 782 820 1358..
8 73 147 427 592 660 743 794 850
11 26 113 236 263 280 281 340 391 414 429 478..
12 14 38 43 49 52 89 173 232 278 325 328 
15 18 21 25 32 45 100 119 168 202 285 298..
29 159 386 430 459 499 508 597 659 731 
68 83 105 132 141 152 177 182 185 226 257.. 
78 91 219 225 231 239 244 255 401 477 524 551..
</programlisting>
    </section>
  </section>
  <section xml:id="k-means-clustering">
    <title>K-means clustering</title>
    <para>
      Given a set of documents, K-means clustering aims to partition the
      documents into a number of sets. Its objective is to minimize the
      residual sum of squares, a measure of how well the centroids
      represent the members of their clusters.
    </para>
    <section xml:id="nlp.cluster.kmeans">
      <title><literal>.nlp.cluster.kmeans</literal></title>
      <para>
        <emphasis>K-means clustering for documents</emphasis>
      </para>
      <para>
        Syntax: <literal>.nlp.cluster.kmeans[docs;k;iters]</literal>
      </para>
      <para>
        Where
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>docs</literal> is a table or a list of dictionaries
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>k</literal> is the number of clusters to return
            (long)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>iters</literal> is the number of times to iterate
            the refining step (long)
          </para>
        </listitem>
      </itemizedlist>
      <para>
        returns the document’s indexes, grouped into clusters.
      </para>
      <para>
        Partition <emphasis>Moby Dick</emphasis> into 15 clusters; we
        find there is one large cluster present in the book:
      </para>
      <programlisting language="r script">
q)clusters:.nlp.cluster.kmeans[corpus;15;30]
q)count each clusters
32 9 13 9 12 5 12 8 6 8 7 11 11 5 2
</programlisting>
    </section>
  </section>
  <section xml:id="bisecting-k-means">
    <title>Bisecting K-means</title>
    <para>
      Bisecting K-means adopts the K-means algorithm and splits a
      cluster in two. This algorithm is more efficient when
      <emphasis>k</emphasis> is large. For the K-means algorithm, the
      computation involves every data point of the data set and
      <emphasis>k</emphasis> centroids. On the other hand, in each
      bisecting step of Bisecting K-means, only the data points of one
      cluster and two centroids are involved in the computation. Thus
      the computation time is reduced. Secondly, Bisecting K-means
      produce clusters of similar sizes, while K-means is known to
      produce clusters of widely differing sizes.
    </para>
    <section xml:id="nlp.cluster.bisectingkmeans">
      <title><literal>.nlp.cluster.bisectingKmeans</literal></title>
      <para>
        <emphasis>The Bisecting K-means algorithm uses K-means
        repeatedly to split the most cohesive clusters into two
        clusters</emphasis>
      </para>
      <para>
        Syntax:
        <literal>.nlp.cluster.bisectingKmeans[docs;k;iters]</literal>
      </para>
      <para>
        Where
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>docs</literal> is a list of document keywords
            (table or list of dictionaries)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>k</literal> is the number of clusters (long)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>iters</literal> is the number of times to iterate
            the refining step
          </para>
        </listitem>
      </itemizedlist>
      <para>
        returns, as a list of lists of longs, the documents’ indexes,
        grouped into clusters.
      </para>
      <programlisting language="r script">
q)count each .nlp.cluster.bisectingKMeans[corpus;15;30]
8 5 13 5 12 8 10 10 1 12 5 15 1 37 8
</programlisting>
    </section>
  </section>
  <section xml:id="radix-algorithm">
    <title>Radix algorithm</title>
    <para>
      The Radix clustering algorithms are a set of non-comparison,
      binning-based clustering algorithms. Because they do no
      comparisons, they can be much faster than other clustering
      algorithms. In essence, they cluster via topic modeling, but
      without the complexity.
    </para>
    <para>
      Radix clustering is based on the observation that Bisecting
      K-means clustering gives the best cohesion when the centroid
      retains only its most significant dimension, and inspired by the
      canopy-clustering approach of pre-clustering using a very cheap
      distance metric.
    </para>
    <para>
      At its simplest, Radix clustering just bins on most significant
      term. A more accurate version uses the most significant
      <emphasis>n</emphasis> terms in each document in the corpus as
      bins, discarding infrequent bins. Related terms can also be
      binned, and documents matching some percent of a bins keyword go
      in that bin.
    </para>
    <section xml:id="hard-clustering">
      <title>Hard Clustering</title>
      <para>
        Hard Clustering means that each datapoint belongs to a cluster
        completely or not.
      </para>
    </section>
    <section xml:id="nlp.cluster.fastradix">
      <title><literal>.nlp.cluster.fastradix</literal></title>
      <para>
        <emphasis>Uses the Radix clustering algorithm and bins by the
        most significant term</emphasis>
      </para>
      <para>
        Syntax:
        <literal>.nlp.cluster.fastradix[docs;numOfClusters]</literal>
      </para>
      <para>
        Where
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>docs</literal> is a list of documents or document
            keywords (table or a list of dictionaries)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>numOfClusters</literal> is the number of clusters
            (long)
          </para>
        </listitem>
      </itemizedlist>
      <para>
        returns a list of list of longs, the documents’ indexes, grouped
        into clusters.
      </para>
      <para>
        Group Jeff Skilling’s emails into 60 clusters:
      </para>
      <programlisting language="r script">
q)count each .nlp.cluster.radix1[jeffcorpus;60]
15 14 10 9 8 13 9 8 8 6 5 6 6 8 5 6 5 4 4 4 4 4 4 8 4 5 4 4 5 4 4 4 3 3 3 3 3..
</programlisting>
    </section>
    <section xml:id="soft-clustering">
      <title>Soft Clustering</title>
      <para>
        In Soft Clustering, a probability or likelihood of a data point
        to be in a clusters is assigned. This mean that some clusters
        can overlap.
      </para>
    </section>
    <section xml:id="nlp.cluster.radix">
      <title><literal>.nlp.cluster.radix</literal></title>
      <para>
        <emphasis>Uses the Radix clustering algorithm and bins are taken
        from the top 3 terms of each document</emphasis>
      </para>
      <para>
        Syntax:
        <literal>.nlp.cluster.radix[docs;numOfClusters]</literal>
      </para>
      <para>
        Where
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>docs</literal> is a list of documents or document
            keywords (table or a list of dictionaries)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>numOfClusters</literal> is the number of clusters
            (long), which should be large to cover the substantial
            amount of the corpus, as the clusters are small
          </para>
        </listitem>
      </itemizedlist>
      <para>
        returns the documents’ indexes (as a list of longs), grouped
        into clusters.
      </para>
      <para>
        Group Jeff Skilling’s emails into 60 clusters:
      </para>
      <programlisting language="r script">
q)count each .nlp.cluster.radix2[jeffcorpus;60]
9 7 6 7 10 12 6 5 5 5 6 8 6 5 8 5 6 5 5 5 6 7 5 5 5 6 9 6 5 5 9 5 5 8 17 7 37.
</programlisting>
    </section>
  </section>
  <section xml:id="cluster-cohesion">
    <title>Cluster cohesion</title>
    <para>
      The cohesiveness of a cluster is a measure of how similar the
      documents are within that cluster. It is calculated as the mean
      sum-of-squares error, which aggregates each document’s distance
      from the centroid. Sorting by cohesiveness will give very focused
      clusters first.
    </para>
    <section xml:id="nlp.cluster.mse">
      <title><literal>.nlp.cluster.MSE</literal></title>
      <para>
        <emphasis>Cohesiveness of a cluster as measured by the mean
        sum-of-squares error</emphasis>
      </para>
      <para>
        Syntax: <literal>.nlp.cluster.MSE x</literal>
      </para>
      <para>
        Where <literal>x</literal> is a list of dictionaries which are a
        document’s keyword field, returns as a float the cohesion of the
        cluster.
      </para>
      <programlisting language="r script">
q)/16 emails related to donating to charity
q)charityemails:jeffcorpus where jeffcorpus[`text] like &quot;*donate*&quot;
q).nlp.cluster.MSE charityemails`keywords
0.1177886

q)/10 emails chosen at random
q).nlp.cluster.MSE (-10?jeffcorpus)`keywords
0.02862244
</programlisting>
    </section>
  </section>
  <section xml:id="grouping-documents-to-centroids">
    <title>Grouping documents to centroids</title>
    <para>
      When you have a set of centroids and you would like to find out
      which centroid is closest to the documents, you can use this
      function.
    </para>
    <section xml:id="nlp.cluster.groupbycentroid">
      <title><literal>.nlp.cluster.groupByCentroid</literal></title>
      <para>
        <emphasis>Documents matched to their nearest centroid</emphasis>
      </para>
      <para>
        Syntax:
        <literal>.nlp.cluster.matchDocswithCentroid[centroid;docs]</literal>
      </para>
      <para>
        Where
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>centroid</literal> is a list of the centroids as
            keyword dictionaries
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>documents</literal> is a list of document feature
            vectors
          </para>
        </listitem>
      </itemizedlist>
      <para>
        returns, as a list of lists of longs, document indexes where
        each list is a cluster.
      </para>
      <para>
        Matches the first centroid of the clusters with the rest of the
        corpus:
      </para>
      <programlisting language="r script">
q).nlp.cluster.groupByCentroids[[corpus clusters][0][`keywords];corpus`keywords]
0 23 65 137
1 5 14 45 81
2 6 7 13 15 16 17 19 20 21 26 27 31 40 44 47 48 49 50 54 57 58 62 63 66 67 68..
3 9 10
,4
8 51 55 95 96 108 112 117 129 132 136 146 148
11 12
,18
22 25
,24
28 53 61 72 82 83 86 91 113 130 147
,29
,30
32 33 79 98 104 105 107 131
34 97
35 37 38 39 41 42
36 133 149
43 60 64 74 106 115
</programlisting>
    </section>
  </section>
</section>
<section xml:id="finding-outliers-and-representative-documents">
  <title>Finding outliers, and representative documents</title>
  <para>
    The <emphasis>centroid</emphasis> of a collection of documents is
    the average of their feature vectors. As such, documents close to
    the centroid are representative, while those far away are the
    outliers. Given a collection of documents, finding outliers can be a
    quick way to find interesting documents, those that have been
    mis-clustered, or those not relevant to the collection.
  </para>
  <para>
    The emails of former Enron CEO Ken Lay contain 1124 emails with a
    petition. Nearly all of these use the default text, only changing
    the name, address and email address. To find those petitions which
    have been modified, sorting by distance from the centroid gives
    emails where the default text has been completely replaced, added
    to, or has had portions removed, with the emails most heavily
    modified appearing first.
  </para>
  <section xml:id="nlp.comparedoctocentroid">
    <title><literal>.nlp.compareDocToCentroid</literal></title>
    <para>
      <emphasis>Cosine similarity of a document and a centroid,
      subtracting the document from the centroid</emphasis>
    </para>
    <para>
      Syntax:
      <literal>.nlp.compareDocToCentroid[centroid;document]</literal>
    </para>
    <para>
      Where
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <literal>centroid</literal> is the sum of all documents in a
          cluster which is a dictionary
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>document</literal> is a document in a cluster which
          is a dictionary
        </para>
      </listitem>
    </itemizedlist>
    <para>
      returns the cosine similarity of the two documents as a float.
    </para>
    <programlisting language="r script">
q)petition:laycorpus where laycorpus[`subject] like &quot;Demand Ken*&quot;
q)centroid:sum petition`keywords
q).nlp.compareDocToCentroid[centroid]each petition`keywords
0.2374891 0.2308969 0.2383573 0.2797052 0.2817323 0.3103245 0.279753 0.2396462 0.3534717 0.369767
q)outliers:petition iasc .nlp.compareDocToCentroid[centroid]each petition`keywords
</programlisting>
  </section>
  <section xml:id="searching">
    <title>Searching</title>
    <para>
      Searching can be done using words, documents, or collections of
      documents as the query or dataset. To search for documents similar
      to a given document, you can represent all documents as feature
      vectors using TF-IDF, then compare the cosine similarity of the
      query document to those in the dataset and find the most similar
      documents, with the cosine similarity giving a relevance score.
    </para>
    <para>
      The following example searches using
      <literal>.nlp.compareDocs</literal> for the document most similar
      to the below email where former Enron CEO Jeff Skilling is
      discussing finding a new fire chief.
    </para>
    <programlisting language="r script">
q)queryemail:first jeffcorpus where jeffcorpus[`text] like &quot;Fire Chief Committee*&quot;  
q)-1 queryemail`text;
q)mostsimilar:jeffcorpus first 1_idesc .nlp.compareDocs[queryemail`keywords]each jeffcorpus`keywords

Select Comm AGENDA - Jan 25-Febr 1

Houston Fire Chief Selection Committee Members: Jeff Skilling - Chairperson, 
Troy Blakeney, Gerald Smith, Roel Campos and James Duke.

Congratulations selection committee members! We have a very important and 
exciting task ahead of us. 

On the agenda for the next week are two important items - (1) the Mayor's 
February 1 news conference announcing the Houston Fire Chief selection 
committee and its members; and (2) coordination of an action plan, which we 
should work out prior to the news conference.

News Conference specifics:
speakers - Mayor Brown and Jeff Skilling
in attendance - all selection committee members
location - Fire Station #6, 3402 Washington Ave.
date - Thursday, February 1, 2001
time - 2pm
duration - approximately 30 minutes

I'd like to emphasize that it would be ideal if all selection committee 
members were present at the news conference. 

I will need bios on each committee member emailed to me by close of business 
Monday, January 29, 2001. These bios will be attached to a press release the 
Mayor's Office is compiling.

Coordination of action plan:
Since we have only 1 week between now and the news conference, Jeff has 
proposed that he take a stab at putting together an initial draft. He will 
then email to all committee members for comments/suggestions and make changes 
accordingly. Hope this works for everyone - if not, give me a call 
(713)-345-4840.

Thanks,
Lisa
</programlisting>
  </section>
</section>
<section xml:id="explaining-similarities">
  <title>Explaining similarities</title>
  <para>
    For any pair of documents or centroids, the list of features can be
    sorted by how much they contribute to the similarity.
  </para>
  <para>
    This example compares two of former Enron CEO Jeff Skilling’s
    emails, both of which have in common the subject of selecting
    Houston’s next fire chief.
  </para>
  <section xml:id="nlp.explainsimilarity">
    <title><literal>.nlp.explainSimilarity</literal></title>
    <para>
      Syntax: <literal>.nlp.explainSimilarity[doc1;doc2]</literal>
    </para>
    <para>
      Where <literal>doc1</literal> and <literal>doc2</literal> are
      dictionaries consisting of their associated documents’ keywords,
      returns a dictionary of how much of the similarity score each
      token is responsible for.
    </para>
    <programlisting language="r script">
q)10#.nlp.explainSimilarity . jeffcorpus[`keywords]568 358
fire     | 0.2588778
roel     | 0.1456685
committee| 0.1298068
mayor    | 0.1295087
station  | 0.09342764
chief    | 0.06948782
select   | 0.04325209
important| 0.03838308
members  | 0.03530552
plan     | 0.02459828
</programlisting>
  </section>
</section>
<section xml:id="sentiment-analysis">
  <title>Sentiment analysis</title>
  <para>
    Using a pre-built model of the degrees of positive and negative
    sentiment for English words and emoticons, as well as parsing to
    account for negation, adverbs and other modifiers, sentences can be
    scored for their negative, positive and neutral sentiment. The model
    included has been trained on social-media messages.
  </para>
  <section xml:id="nlp.sentiment">
    <title><literal>.nlp.sentiment</literal></title>
    <para>
      <emphasis>Sentiment of a sentence</emphasis>
    </para>
    <para>
      Syntax: <literal>.nlp.sentiment x</literal>
    </para>
    <para>
      Where <literal>x</literal> is string or a list of strings, returns
      a dictionary or table containing the sentiment of the text.
    </para>
    <para>
      An run of sentences from <emphasis>Moby Dick</emphasis>:
    </para>
    <programlisting language="r script">
q).nlp.sentiment(&quot;Three cheers,men--all hearts alive!&quot;;&quot;No,no! shame upon all cowards-shame upon them!&quot;)
compound   pos       neg       neu      
----------------------------------------
0.7177249  0.5996797 0         0.4003203
-0.8802318 0         0.6910529 0.3089471
</programlisting>
  </section>
</section>
<section xml:id="importing-and-parsing-mbox-files">
  <title>Importing and parsing MBOX files</title>
  <para>
    The MBOX file is the most common format for storing email messages
    on a hard drive. All the messages for each mailbox are stored as a
    single, long, text file in a string of concatenated e-mail messages,
    starting with the <emphasis>From</emphasis> header of the message.
    The NLP library allows the user to import these files and creates a
    kdb+ table.
  </para>
  <informaltable>
    <tgroup cols="3">
      <colspec align="left" />
      <colspec align="left" />
      <colspec align="left" />
      <thead>
        <row>
          <entry>
            Column
          </entry>
          <entry>
            Type
          </entry>
          <entry>
            Content
          </entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>
            <literal>sender</literal>
          </entry>
          <entry>
            list of characters
          </entry>
          <entry>
            The name and email address of the sender
          </entry>
        </row>
        <row>
          <entry>
            <literal>to</literal>
          </entry>
          <entry>
            list of characters
          </entry>
          <entry>
            The name and email address of the reciever/recievers
          </entry>
        </row>
        <row>
          <entry>
            <literal>date</literal>
          </entry>
          <entry>
            timestamp
          </entry>
          <entry>
            The date
          </entry>
        </row>
        <row>
          <entry>
            <literal>subject</literal>
          </entry>
          <entry>
            list of characters
          </entry>
          <entry>
            The subject of the email
          </entry>
        </row>
        <row>
          <entry>
            <literal>text</literal>
          </entry>
          <entry>
            list of characters
          </entry>
          <entry>
            The original text of the email
          </entry>
        </row>
        <row>
          <entry>
            <literal>contentType</literal>
          </entry>
          <entry>
            list of characters
          </entry>
          <entry>
            The content type of the email
          </entry>
        </row>
        <row>
          <entry>
            <literal>payload</literal>
          </entry>
          <entry>
            list of characters or dictionaries
          </entry>
          <entry>
            The payload of the email
          </entry>
        </row>
      </tbody>
    </tgroup>
  </informaltable>
  <section xml:id="nlp.loademails">
    <title><literal>.nlp.loadEmails</literal></title>
    <para>
      <emphasis>An MBOX file as a table of parsed metadata</emphasis>
    </para>
    <para>
      Syntax: <literal>.nlp.loadEmails x</literal>
    </para>
    <para>
      Where <literal>x</literal> is a string of the filepath, returns a
      table.
    </para>
    <programlisting language="r script">
q)email:.nlp.email.getMbox[&quot;/home/kx/nlp/datasets/tdwg.mbox&quot;]
q)cols email
`sender`to`date`subject`contentType`payload`text
</programlisting>
  </section>
  <section xml:id="nlp.email.getgraph">
    <title><literal>.nlp.email.getGraph</literal></title>
    <para>
      <emphasis>Graph of who emailed whom, with the number of times they
      emailed</emphasis>
    </para>
    <para>
      Syntax: <literal>.nlp.email.getGraph x</literal>
    </para>
    <para>
      Where <literal>x</literal> is a table (result from
      <literal>.nlp.email.i.parseMbox</literal>), returns a table of
      to-from pairing.
    </para>
    <programlisting language="r script">
q).nlp.email.getGraph[emails]

sender                           to                               volume
------------------------------------------------------------------------
Donald.Hobern@csiro.au           tdwg-img@lists.tdwg.org          1     
Donald.Hobern@csiro.au           tdwg@lists.tdwg.org              1     
Donald.Hobern@csiro.au           vchavan@gbif.org                 1     
RichardsK@landcareresearch.co.nz tdwg-img@lists.tdwg.org          1     
Robert.Morris@cs.umb.edu         Tdwg-tag@lists.tdwg.org          1     
Robert.Morris@cs.umb.edu         tdwg-img@lists.tdwg.org          1     
mdoering@gbif.org                lee@blatantfabrications.com      1     
mdoering@gbif.org                tdwg-img@lists.tdwg.org          1     
morris.bob@gmail.com             tdwg-img@lists.tdwg.org          1     
ram@cs.umb.edu                   RichardsK@landcareresearch.co.nz 1     
ram@cs.umb.edu                   tdwg-img@lists.tdwg.org          2     
ricardo@tdwg.org                 a.rissone@nhm.ac.uk              3     
ricardo@tdwg.org                 leebel@netspace.net.au           3     
ricardo@tdwg.org                 tdwg-img@lists.tdwg.org          3     
ricardo@tdwg.org                 tdwg-lit@lists.tdwg.org          3     
ricardo@tdwg.org                 tdwg-obs@lists.tdwg.org          3     
ricardo@tdwg.org                 tdwg-process@lists.tdwg.org      3     
ricardo@tdwg.org                 tdwg-tag@lists.tdwg.org          3     
ricardo@tdwg.org                 tdwg-tapir@lists.tdwg.org        3     
roger@tdwg.org                   Tdwg-img@lists.tdwg.org          1     
</programlisting>
  </section>
</section>
<section xml:id="parsing-emails-from-a-string-format">
  <title>Parsing emails from a string format</title>
  <section xml:id="nlp.email.parsemail">
    <title><literal>.nlp.email.parseMail</literal></title>
    <para>
      <emphasis>Parses an email in string format</emphasis>
    </para>
    <para>
      Syntax: <literal>.nlp.email.parseMail x</literal>
    </para>
    <para>
      Where <literal>x</literal> is an email in a string format, returns
      a dictionary of the headers and content.
    </para>
    <programlisting language="r script">
q)table:.nlp.email.parseMail emailString
q)table 
`headers`content
</programlisting>
  </section>
</section>
<section xml:id="useful-functions">
  <title>Useful functions</title>
  <para>
    These are functions that extract elements of the text that can be
    applied to NLP algorithms, or that can help you with your analysis.
  </para>
  <section xml:id="nlp.findtimes">
    <title><literal>.nlp.findTimes</literal></title>
    <para>
      <emphasis>All the times in a document</emphasis>
    </para>
    <para>
      Syntax: <literal>.nlp.findTimes x</literal>
    </para>
    <para>
      Where <literal>x</literal> is a string, returns a general list:
    </para>
    <orderedlist numeration="arabic" spacing="compact">
      <listitem>
<literallayout>time
</literallayout>
      </listitem>
      <listitem>
        <para>
          text of the time (string)
        </para>
      </listitem>
      <listitem>
        <para>
          start index (long)
        </para>
      </listitem>
      <listitem>
        <para>
          index after the end index (long)
        </para>
      </listitem>
    </orderedlist>
    <programlisting language="r script">
q).nlp.findTimes &quot;I went to work at 9:00am and had a coffee at 10:20&quot;
09:00:00.000 &quot;9:00am&quot; 18 24
10:20:00.000 &quot;10:20&quot;  45 50
</programlisting>
  </section>
  <section xml:id="nlp.finddates">
    <title><literal>.nlp.findDates</literal></title>
    <para>
      <emphasis>All the dates in a document</emphasis>
    </para>
    <para>
      Syntax: <literal>.nlp.findDates x</literal>
    </para>
    <para>
      Where <literal>x</literal> is a string
    </para>
    <para>
      returns a general list:
    </para>
    <orderedlist numeration="arabic" spacing="compact">
      <listitem>
        <para>
          start date of the range
        </para>
      </listitem>
      <listitem>
        <para>
          end date of the range
        </para>
      </listitem>
      <listitem>
        <para>
          text of the range
        </para>
      </listitem>
      <listitem>
        <para>
          start index of the date (long)
        </para>
      </listitem>
      <listitem>
        <para>
          index after the end index (long)
        </para>
      </listitem>
    </orderedlist>
    <programlisting language="r script">
q).nlp.findDates &quot;I am going on holidays on the 12/04/2018 to New York and come back on the 18.04.2018&quot;
2018.04.12 2018.04.12 &quot;12/04/2018&quot; 30 40
2018.04.18 2018.04.18 &quot;18.04.2018&quot; 74 84
</programlisting>
  </section>
  <section xml:id="nlp.getsentences">
    <title><literal>.nlp.getSentences</literal></title>
    <para>
      <emphasis>A document partitioned into sentences.</emphasis>
    </para>
    <para>
      Syntax: <literal>.nlp.getSentences x</literal>
    </para>
    <para>
      Where <literal>x</literal> is a dictionary or a table of document
      records or subcorpus, returns a list of strings.
    </para>
    <programlisting language="r script">
/finds the sentences in the first chapter of MobyDick
q) .nlp.getSentences corpus[0]
</programlisting>
  </section>
  <section xml:id="nlp.loadtextfromdir">
    <title><literal>.nlp.loadTextFromDir</literal></title>
    <para>
      <emphasis>All the files in a directory, imported
      recursively</emphasis>
    </para>
    <para>
      Syntax: <literal>.nlp.loadTextFromDir x</literal>
    </para>
    <para>
      Where <literal>x</literal> the directory’s filepath as a string,
      returns a table of filenames, paths and texts.
    </para>
    <programlisting language="r script">
q).nlp.loadTextFromDir[&quot;./datasets/maildir/skilling-j&quot;]

fileName path                                           text                 ..
-----------------------------------------------------------------------------..
1.       :./datasets/maildir/skilling-j/_sent_mail/1.   &quot;Message-ID: &lt;1461010..
10.      :./datasets/maildir/skilling-j/_sent_mail/10.  &quot;Message-ID: &lt;1371054..
100.     :./datasets/maildir/skilling-j/_sent_mail/100. &quot;Message-ID: &lt;47397.1..
101.     :./datasets/maildir/skilling-j/_sent_mail/101. &quot;Message-ID: &lt;2486283..
</programlisting>
  </section>
</section>
</article>
